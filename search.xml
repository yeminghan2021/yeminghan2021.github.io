<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>[ABC387G] Prime Circuit</title>
    <url>/2025/01/04/ABC387G-Prime-Circuit/</url>
    <content><![CDATA[<h2 id="statements">Statements</h2>
<p>给定 <span class="math inline">\(n\)</span>，求满足下列条件的 <span
class="math inline">\(n\)</span>
点有标号、连通、简单、无向图的数量：</p>
<blockquote>
<p>对于该图中任意不重复经过某条<strong>边</strong>的环，其长度都为<strong>质数</strong>。</p>
</blockquote>
<p>Data range：<span
class="math inline">\(n\le2.5\times10^5\)</span>。</p>
<p>Time limit：<strong>12s</strong>。</p>
<h2 id="solution">Solution</h2>
<p>首先肯定要刻画一下这图长啥样。</p>
<p>考虑一个边双的形状。</p>
<blockquote>
<p>Lemma：一个边双必然是一个环或一个单点。</p>
<p>Proof：如果不是，那么至少有两个环。</p>
<p>考虑随便拿出两个相交于一条链的环（链可能退化成点）。那么这条链有两个端点
<span class="math inline">\(x,y\)</span>。</p>
<p>画个图就能得知，此时 <span class="math inline">\(x,y\)</span>
之间存在三条互不相交的路径，设其长度为 <span
class="math inline">\(a,b,c\)</span>。（如果 <span
class="math inline">\(x=y\)</span>，那么有一个是 <span
class="math inline">\(0\)</span>。）</p>
<p>此时容易至少发现存在三个长分为 <span
class="math inline">\(a+b,b+c,c+a\)</span> 的环。</p>
<p>显然环长不可能为 <span
class="math inline">\(2\)</span>，所以环长为奇（质）数，所以其和也是奇数。但又有环长之和等于
<span class="math inline">\((a+b)+(b+c)+(c+a)=2(a+b+c)\)</span>
是偶数，矛盾！</p>
</blockquote>
<p>考虑钦定所有环长为 <span
class="math inline">\(l_1,l_2,\ldots,l_k\)</span>，然后计数：</p>
<ul>
<li>每个环有 <span
class="math inline">\(\dfrac{(l_i-1)!}{2-[l_i=1]}\)</span> 种方案；</li>
<li>将这些环连成一棵树（因为边双缩起来是树），根据<a
href="https://oi-wiki.org/graph/prufer/#%E5%9B%BE%E8%BF%9E%E9%80%9A%E6%96%B9%E6%A1%88%E6%95%B0">这里</a>的结论可以得到方案数为
<span class="math inline">\(n^{k-2}\cdot\prod l_i\)</span>；</li>
<li>分配环中的点，这个就是一堆组合数。</li>
</ul>
<p>然后就可以考虑 dp。</p>
<p>令 <span class="math inline">\(dp_i\)</span> 表示还剩 <span
class="math inline">\(i\)</span> 个点时，方案数乘 <span
class="math inline">\(n^2\)</span>（这样那个幂就变成了 <span
class="math inline">\(n^k\)</span>）的值。</p>
<p>那么不难列出转移方程：</p>
<p><span class="math display">\[dp_i=\sum_{\substack{(j\in\mathbb P\land
j\ne2)\lor j=1\\i+j\le
n}}\binom{i+j-1}{j-1}\cdot\frac{(j-1)!}{2-[j=1]}\cdot j\cdot n\cdot
dp_{i+j}\]</span></p>
<p>其中组合数是分配点；<span class="math inline">\(n\)</span> 是对 <span
class="math inline">\(n^k\)</span> 的贡献。初值为 <span
class="math inline">\(dp_n=1\)</span>；答案即为 <span
class="math inline">\(\dfrac{dp_0}{n^2}\)</span>。</p>
<p>由结论可知 <span class="math inline">\(|\mathbb P|=\Theta\left(\dfrac
n{\log
n}\right)\)</span>；所以总复杂度为 <span
class="math inline">\(\Theta\left(\dfrac{n^2}{\log
n}\right)\)</span>。</p>
<p>这玩意写的时候注意一下常数就可以通过了。</p>
<ul>
<li>什么？你说 <span class="math inline">\(o(n^{1.99})\)</span>
做法？我太菜，不会。</li>
</ul>
<h2 id="code">Code</h2>
<p>在 AT 机子上跑了 10.66s，还是需要一点卡常。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Author: YE Minghan</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PB emplace_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PPB pop_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MP make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ALL(Name) Name.begin(),Name.end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PII pair<span class="string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VI vector<span class="string">&lt;int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GI greater<span class="string">&lt;int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD=<span class="number">998244353</span>,N=<span class="number">250005</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> fac[N],ifac[N];</span><br><span class="line"><span class="type">int</span> dp[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pw</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y=MOD<span class="number">-2</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> r=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(y)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(y&amp;<span class="number">1</span>)r=<span class="number">1ll</span>*r*x%MOD;</span><br><span class="line">		x=<span class="number">1ll</span>*x*x%MOD,y&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> p[N];</span><br><span class="line">VI S;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>),cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="comment">//	int _;cin&gt;&gt;_;while(_--)</span></span><br><span class="line"></span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	fac[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)fac[i]=<span class="number">1ll</span>*fac[i<span class="number">-1</span>]*i%MOD,p[i]=<span class="number">1</span>;</span><br><span class="line">	ifac[n]=<span class="built_in">pw</span>(fac[n]);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>;~i;i--)ifac[i]=(i<span class="number">+1ll</span>)*ifac[i<span class="number">+1</span>]%MOD;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">		<span class="keyword">if</span>(p[i])</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=i&lt;&lt;<span class="number">1</span>;j&lt;=n;j+=i)p[j]=<span class="number">0</span>;</span><br><span class="line">	S.<span class="built_in">PB</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">3</span>;i&lt;=n;i++)</span><br><span class="line">		<span class="keyword">if</span>(p[i])S.<span class="built_in">PB</span>(i);</span><br><span class="line">	dp[n]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>;~i;i--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j:S)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(i+j&gt;n)<span class="keyword">break</span>;</span><br><span class="line">			dp[i]=(dp[i]+(<span class="number">1ll</span>+(j==<span class="number">1</span>))*fac[i+j<span class="number">-1</span>]*j%MOD*dp[i+j])%MOD;</span><br><span class="line">		&#125;</span><br><span class="line">		dp[i]=<span class="number">1ll</span>*dp[i]*n%MOD*ifac[i]%MOD*(MOD<span class="number">+1</span>&gt;&gt;<span class="number">1</span>)%MOD;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;<span class="number">1ll</span>*dp[<span class="number">0</span>]*<span class="built_in">pw</span>(n,MOD<span class="number">-3</span>)%MOD&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>solutions</category>
        <category>AtCoder</category>
      </categories>
  </entry>
  <entry>
    <title>THUPC 2025 单开记</title>
    <url>/2024/12/12/THUPC-2025-%E5%8D%95%E5%BC%80%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="day--">Day -?</h2>
<p>问了一下一起训练的人，没一个想打/来打的。</p>
<p>于是喜提一缺二。</p>
<p>队名：<code>1v3er</code></p>
<h2 id="day-1">Day 1</h2>
<p>0:00 开始！</p>
<p>一眼丁真 M 是签到，<strong>0:01</strong> 过了。</p>
<p><del>之后就完全是跟榜了。</del></p>
<p>然后随机扫了几眼题，看到 C 有人过，就去看 C。</p>
<p>想了几分钟得出结论是 <span class="math inline">\(\max(\text{全局第 3
小},\text{和 }a_x\text{ 相邻的数中的第 2 小})\)</span>。</p>
<p>然后因为第二小写成第二大而挂一发。<strong>0:17</strong>
改完过了。</p>
<p>然后发现好几个题都有人过了。随机想了一会题。</p>
<p>这个 L 为啥几分钟就有人过了？为啥我一点不会？</p>
<p>发现 J 是「与黑点相邻的点至少与一个白点相邻」。这不直接瞎树形 dp
吗。</p>
<p>写完发现 WA 了。然后发现我 dp
的东西根本不是我设的状态。<strong>0:43</strong> 改完过了。</p>
<p>然后看了一眼 I。这不直接 <span
class="math inline">\(\Theta(11n)\)</span> dp 吗。</p>
<p>然后因为「打了 <span class="math inline">\(2\)</span> 局比赛，比分是
<span class="math inline">\(10:10\)</span>」这种 corner case 而 WA
了一发。<strong>0:55</strong> 改完过了。</p>
<p>为啥我还是不会 L 啊？？？看着像 <span
class="math inline">\(\Theta(\frac{n^2}w)\)</span>，但是我连个 P
都不会？</p>
<p>看 D。发现 <span class="math inline">\(\Theta(n\log W)\)</span>
次分配之后一定会变成 <span class="math inline">\(n\)</span>
个人轮流拿。</p>
<p>那不是直接上个 <code>pq</code> 就行了吗？</p>
<p>01:25 过样例，发现 WA 了。发现中间运算可能爆
<code>long long</code>。改成了 <code>__int128</code>。然后 TLE 了。</p>
<p><del>我就知道俩烙鸽过不去。。。</del></p>
<p>发现有单调性，可以把 <code>pq</code> 换成三个
<code>queue</code>，分别维护拿到 <span
class="math inline">\(0\)</span>、<span
class="math inline">\(1\)</span>、<span class="math inline">\(\ge
2\)</span> 个的人。改改改，然后又写挂了两发。<strong>1:48</strong>
过了。</p>
<p>现在还剩 A, G, H, L 几个题过的人比较多。</p>
<p>H 是大 DS，我一个人怎么可能写的动，暂时扔掉。A 题看着是神秘 DP，G
题是神秘博弈论，L 不知道。</p>
<p>决定想 L，然后转成了另类最小割，然后转成了二分图最大独立集。</p>
<p>不是哥们，你 <span class="math inline">\(\Theta(n)\)</span> 个点
<span class="math inline">\(\Theta(n^2)\)</span>
条边（尽管可以缩起来）的图，跑牛魔匈牙利啊？</p>
<p>然后愣了整整几分钟：WC，这不是直接 Dinic 没了吗？</p>
<p>偷了个 Dinic 板子，然后 1A 了。此时是 <strong>2:34</strong>。</p>
<p>看了下 G 过的人最多，遂看 G。这真好做吗？</p>
<p>感觉需要直接想策略。然后推了半天，推出了一个看起来不太真的策略。</p>
<p>写了一下，过样例了，奶了一口会 WA，交上去，过了！此时是
<strong>3:39</strong>。</p>
<p>最后 80min，决定冲 A。</p>
<p>想了半天才转化成区间 dp，然后发现是 <span
class="math inline">\(\Theta(n^5)\)</span> 的。虽然带了 <span
class="math inline">\(\frac 1{12}\)</span> 的常数但显然是不可能过 <span
class="math inline">\(150\)</span> 的。</p>
<p>组合意义感觉优化不动，有点急了，列出了转移方程，发现可以提出一个东西出来，然后就
<span class="math inline">\(\Theta(n^4)\)</span> 了！</p>
<p>开写，<strong>4:53</strong> 过了样例，提交，AC 了！</p>
<p>剩 7min 肯定啥也干不了了，遂摆烂。</p>
<hr />
<p>最终战绩为 <strong>8 / 17:14:16 / rk156</strong>。</p>
<p>感觉作为单挑这个题数已经不少了。<del>如果来一两个水平差不多的队友可能就能进决赛了。</del></p>
<p>H 题看着吓人，实际上可以简单地发现 next 的总变化不超过 <span
class="math inline">\(\Theta(n\log n)\)</span>，可能也没那么难？</p>
<p>总结：明年得凑齐必有我师焉再打。</p>
]]></content>
      <categories>
        <category>游记</category>
        <category>XCPC</category>
      </categories>
  </entry>
  <entry>
    <title>NOIP 2024</title>
    <url>/2024/11/24/NOIP-2024/</url>
    <content><![CDATA[<h2 id="day--">Day -??</h2>
<p>CSP-S <span class="math inline">\(376\)</span>，GD
rk16。也是把准考证号干到 <strong>GD-0020</strong> 了。</p>
<p>考点：gdfz 3 考场 48 号。</p>
<p>模拟赛打得一天比一天爆。怎么打感觉也进不了队。你见过 NOI <span
class="math inline">\(455\)</span>，CSP-S 模拟 <span
class="math inline">\(110\)</span>，NOIP 模拟 <span
class="math inline">\(80\)</span>
的吗？？？<del>好吧你见过，这是我。</del></p>
<h2 id="day--1">Day -1</h2>
<p>回到了抢州。</p>
<p>试图二刷 建造军营 结果二次破防了。写牛魔，摆！（flag 1）</p>
<h2 id="day-0">Day 0</h2>
<p>在 CF 上发了<a
href="https://codeforces.com/blog/entry/136683?#comment-1222411">我想 AK
NOIP</a>。</p>
<p>打完 NOIP 晚上还有 ABC &amp; CF 1+2：爽！！</p>
<h2 id="day-1">Day 1</h2>
<p>开题：</p>
<p>T1
有点神秘，糊了个贪心糊了个一点也不严谨的证明就开打，过了样例就扔了。</p>
<p>T2，不是哥们，谁家 J 组 T2 扔这来了。此时是 9:15。</p>
<p>T3，一堆团连成一个树状物求 dfs 序数量。发现每个团内是一条链。发现 AB
性质送的，<span class="math inline">\(k=1\)</span>
送的。暂时没思路了。</p>
<p>T4，发现区间 <span class="math inline">\(\operatorname{lca}\)</span>
可以 <span class="math inline">\(\Theta(n\log n+q)\)</span>，32
分送的。</p>
<p>T3，发现可以容斥做到 <span
class="math inline">\(\Theta(T2^kn)\)</span>，现在有 64 分了。</p>
<p>现在大概 10:30，已经 296 分了，看起来很赢！（flag 2）</p>
<p>并没有立刻写，而是打算冲正解。（flag 3）</p>
<p>然后……对着 T3 编了个树形 dp，然后…………</p>
<p>错。修。错。修。错。修。</p>
<p>12:20。发现 T3 假光了。</p>
<p>删掉。删掉。删掉。不，是不是还能……</p>
<p>还 ** 的修个 der 啊！！！拼部分分啊！！！</p>
<p>12:52 T3 终于调出了 64 分。</p>
<p>不测 linux 了！写 T4！12:53，12:54，12:55，12:56，</p>
<p>写牛魔啊！看看 freopen，加了，关了，盯着表。</p>
<p>12:57。</p>
<hr />
<p>100+100+64+0。</p>
<p>大家全都 340，360 什么什么的。</p>
<p>悬着的心终于死了。</p>
<hr />
<p>躺到床上。憋不住了。</p>
<p>不断对自己说「只差个大几十分，省选翻盘还是有希望的」「CSP-S
发挥不完全，NOIP 完全不发挥，省选必完全发挥」。</p>
<p>尽管心里知道只是在安慰自己。</p>
<hr />
<p>晚上 CF 倒是回 grandmaster 了，但是谁让你 NOIP 给 CF 攒 RP
了？？？？</p>
<h2 id="day-2---day">Day 2 - Day ?</h2>
<p>把 lg 签名改成了「三分联注定，七分选打拼」。</p>
<p>CF 又被 speedforces 拽回 IM 了，看来 RP 并没有被吃（bushi</p>
<h2 id="day">Day ?</h2>
<p>没有挂分，也没有反向挂分。</p>
<p>不幸中的万幸吧，省选起码还能垂死挣扎一下（？</p>
<p>队线听人说 340，看来要翻的并没有那么多（？</p>
<p>省选让我完全发挥好吗。我真的好想打 NOI 啊。</p>
<hr />
<h2 id="总结">总结</h2>
<ul>
<li>Flag 1：哼，没想到吧！我 NOIP
又出这种题辣！！！你就等死吧！！！</li>
<li>Flag
2：不要半场开香槟好吗？不要半场开香槟好吗？？不要半场开香槟好吗？？？</li>
<li>Flag 3：<span class="math inline">\(70+55&gt;100+15\)</span>
这个道理你懂不懂啊？？？</li>
</ul>
]]></content>
      <categories>
        <category>游记</category>
        <category>2024-2025</category>
      </categories>
  </entry>
  <entry>
    <title>CSP 2024</title>
    <url>/2024/09/27/CSP-2024/</url>
    <content><![CDATA[<p>GD-S01190/GD-S00489。</p>
<h2 id="day--2omegasim--omega">Day <span
class="math inline">\(-2\omega\sim -\omega\)</span></h2>
<p>开学了。正式成为了高一 OIer。回学校上了一周，然后就停课了。</p>
<p>去打了高联。有个唐诗做一试 T1 时在草稿纸上写下了 <span
class="math inline">\(8^{9^{2024}}=2^{27^{2024}}\)</span>，我不说是谁。椭圆双曲线啥的都忘光了。二试做完
T1T3 就对着几何题罚坐了。</p>
<p>CSP 模拟赛暴打 110pts，遗言丁真鉴定为原形毕露了。</p>
<p>如此成绩，如何 CSP？如此成绩，如何 CSP？如此成绩，如何 CSP？</p>
<h2 id="day--omega">Day <span
class="math inline">\(-\omega\)</span></h2>
<p>初赛。</p>
<p>没啥好说的。1h 速通掉了。完善程序 <span
class="math inline">\(9\)</span> 个 <span class="math inline">\(\texttt
A\)</span> 咋搞的。</p>
<p>在草稿纸上默写了《山东车牌歌》和元素周期表。<del>后来发现「鲁 M
滨州」的「滨」写成不带三点水的了</del></p>
<p>没有对答案，<del>毕竟三年前过今年不过是不是。。。</del></p>
<h2 id="day--omegasim-0">Day <span class="math inline">\(-\omega\sim
0\)</span></h2>
<p>最近 CFAT 状态经常爆炸。在上 GM 7 个月后成功地掉到了 IM。在上 3 Dan 5
个月后成功的掉到了黄名。</p>
<p>国庆模拟赛。爆！爆！爆！摆！摆！摆！魔怔！</p>
<p>比赛前几天疯狂摆烂。</p>
<p>发现高联 2= 了，但是是 2= rk11，唉 T1T2 不挂就可能 1= 了。</p>
<p>Day <span class="math inline">\(0\)</span> 开始当预言家，押了
greedy/dp/tree/ds。</p>
<h2 id="day-1">Day <span class="math inline">\(1\)</span></h2>
<p>发现考场在七楼，气喘吁吁。</p>
<p>解压密码是随机字符串。</p>
<p>开场开了个 NOI linux，可以传文件，爽！</p>
<p>看 T1。<span class="math inline">\(\max cnt\)</span> 秒了。此时是
15min。</p>
<p>看 T2。超速一定是段区间，二分加贪心秒了。此时是 45min。</p>
<p>看 T3。一眼 <span class="math inline">\(n^2\)</span>
dp，然后线段树优化完了。写写写，过样例了，此时是 1h30m。</p>
<p>把前三题扔到了虚拟机上跑。不是为啥 <code>ulimit -v</code> 和
<code>-fsanitize=address</code> 一起用会爆啊？浪费 5min，急了，把
<code>fsanitize</code> 删了。</p>
<p>看 T4。不会。</p>
<p>回去给 T3 造了组极限。我擦跑了 1.5s？我擦线段树原来是 <span
class="math inline">\(\Theta(Tn\log V)\)</span>
的？发现可以线性，改改改，0.2s 轻松通过，此时是 2h15m。</p>
<p>编了半天编出了 T4 的 <span class="math inline">\(\Theta(Tn\log
n)\)</span>，写写写，样例 2 过，样例 3 过，样例 4……WA 了？</p>
<p>发现假了。此时是 3h20m。</p>
<p>尝试改，发现要多一只 <span
class="math inline">\(\log\)</span>。不管了开改，过了所有样例。</p>
<p>测了一下 T4 效率，发现 <span class="math inline">\(T=16\)</span> 可以
0.5s 轻松跑过？</p>
<p>最后 15min 开摆了。</p>
<p>估分 <span class="math inline">\(100+100+100+76=376\)</span>。</p>
<hr />
<p>出来发现一车人 AK 了。又双叒叕被爆了 T_T</p>
<p>昨天预言的似乎只有 T1 比较准。</p>
<p>听说勾 7 线要 300+？？？不是今年真比去年简单得多吗。</p>
<h2 id="day-2simomega">Day <span
class="math inline">\(2\sim\omega\)</span></h2>
<p>Day <span class="math inline">\(2\)</span> ARC 雪耻，回橙！A
赛后补出来很好玩，B 很套路，C 很聪明，D 很 cn，E 看不懂题解。</p>
<p>Day <span class="math inline">\(3\)</span> vp 了昨天的 global
round。打得很抽象。</p>
<p><img
src="https://cdn.luogu.com.cn/upload/image_hosting/h0d9pmrz.png" /></p>
<p>开始玩 duel，结果分全都掉没了。。。</p>
<h2 id="day-omega">Day <span class="math inline">\(\omega\)</span></h2>
<p>最终分 <span class="math inline">\(376\)</span>，没挂！</p>
<p>小胜一把。</p>
<p>NOIP &amp; 省选 RP++！</p>
<hr />
<p>总结：</p>
<ul>
<li>一定要测蓟县数据！一定要测蓟县数据！一定要测蓟县数据！</li>
<li>假了别急！假了别急！假了别急！</li>
</ul>
]]></content>
      <categories>
        <category>游记</category>
        <category>2024-2025</category>
      </categories>
  </entry>
  <entry>
    <title>ARC 瞎做</title>
    <url>/2024/09/27/ARC-%E7%9E%8E%E5%81%9A/</url>
    <content><![CDATA[<p>范围：<span
class="math inline">\(\text{ARC}[\ge104][\text{C|D|E|F}]\land\text{Difficulty}\ge1600\)</span>。</p>
<h2 id="arc104">ARC104</h2>
<h3 id="c">C</h3>
<p>可以发现一段极小的合法区间必然是这样的一个形式：</p>
<p><span
class="math display">\[[x,x+y],[x+1,x+y+1],\ldots,[x+y-1,x+2y-1].\]</span></p>
<p>然后你直接判区间合法 dp 一下就行了。细节有点多。</p>
<h3 id="d">D</h3>
<p>考虑 dp，令 <span class="math inline">\(dp_{i,j,k}\)</span>
表示考虑了 <span class="math inline">\(1\sim i\)</span>
的所有数字，一共选了 <span class="math inline">\(j\)</span> 个，和为
<span class="math inline">\(k\)</span> 的方案数。</p>
<p><del>直接做是 <span class="math inline">\(n^7\)</span>
的过牛魔啊。。。</del></p>
<p>首先前缀和优化砍掉一个 <span
class="math inline">\(n\)</span>。然后你发现状态数就是这么多，必须优化状态数。</p>
<p>考虑求 <span class="math inline">\(x\)</span> 的答案，不妨整体平移
<span class="math inline">\(x\)</span>，那么就是 <span
class="math inline">\(1-x\)</span> 到 <span
class="math inline">\(n-x\)</span> 各 <span
class="math inline">\(k\)</span> 个，选出若干个和为 <span
class="math inline">\(0\)</span>。</p>
<p>那么设 <span class="math inline">\(dp_{i,j}\)</span> 表示考虑了 <span
class="math inline">\((1-x)\sim(i-x)\)</span> 的所有数，和为 <span
class="math inline">\(j\)</span> 的方案数。那么求单个数的答案是 <span
class="math inline">\(n^4\)</span>
的，<del>常数小也许能冲过去？</del></p>
<p>考虑正负分开算，设 <span class="math inline">\(dp_{i,j}\)</span>
表示考虑 <span class="math inline">\(1\sim i\)</span> 的所有数，和为
<span class="math inline">\(j\)</span> 的方案数。</p>
<p>那么可以发现 <span class="math inline">\(x\)</span> 的答案就是 <span
class="math inline">\(\displaystyle(k+1)\sum_{i=0}^\infty
dp_{x-1,i}\cdot
dp_{n-x,i}\)</span>。（就是正数总和等于负数绝对值总和）</p>
<p>那么时间复杂度为 <span
class="math inline">\(\Theta(n^4)\)</span>。</p>
<h3 id="e">E</h3>
<p>厉害题。看了题解才会。</p>
<p>考虑爆枚这 <span class="math inline">\(n\)</span>
个数的大小关系（<strong>可能相等</strong>），然后算出它的 LIS
长度，那么转化为求方案数。</p>
<p>发现问题变成了：</p>
<blockquote>
<p>给出 <span class="math inline">\(A\)</span>，求满足 <span
class="math inline">\(1\le a_i\le A_i\)</span>
的<strong>严格上升</strong>序列 <span class="math inline">\(a\)</span>
的数量。</p>
</blockquote>
<p>不妨假设 <span class="math inline">\(A\)</span> 不降，<span
class="math inline">\(A_0=0\)</span>。</p>
<p>设 <span class="math inline">\(dp_{i,j}\)</span> 表示将 <span
class="math inline">\(1\sim a_j\)</span> 填在 <span
class="math inline">\([1,A_i]\)</span> 中的方案数。</p>
<p>那么有转移：</p>
<p><span class="math display">\[dp_{i+1,j+k}\gets
\binom{A_{i+1}-A_i}k\cdot dp_{i,j}.\]</span></p>
<p>由于 <span class="math inline">\(k\)</span> 很小直接 <span
class="math inline">\(\Theta(k)\)</span> 算组合数即可。</p>
<p>然后就做完了。时间是 <span
class="math inline">\(\Theta(n^n\cdot\mathrm{poly}(n))\)</span>，但是多几只
<span class="math inline">\(n\)</span> 也随便冲。</p>
<h3 id="f">F</h3>
<p>不妨设 <span class="math inline">\(-1\)</span>
的位置有一个无限高的，不影响。</p>
<p>你考虑 <span class="math inline">\(p_i=j\)</span> 的限制就是 <span
class="math inline">\(p_j&gt;p_i\)</span> 且【<span
class="math inline">\(i&lt;k&lt;j\)</span> 时 <span
class="math inline">\(p_j\le p_i\)</span>】。</p>
<p>然后你考虑把笛卡尔树建出来，那么就是左儿子小于等于它的，右儿子小于它的。</p>
<p>那么枚举根就变成两个区间的子问题了，dp 即可。（设 <span
class="math inline">\(dp_{l,r,v}\)</span> 表示 <span
class="math inline">\([l,r]\)</span> 内，值域为 <span
class="math inline">\([1,v]\)</span> 的方案数。）</p>
<p>注意到无论你怎么限制也只需要 <span class="math inline">\(n\)</span>
的值域，所以状态数为 <span
class="math inline">\(\Theta(n^3)\)</span>，转移只需枚举根，所以时间复杂度为
<span class="math inline">\(\Theta(n^4)\)</span>。</p>
<h2 id="arc105">ARC105</h2>
<h3 id="c-1">C</h3>
<p>首先这题很难把骆驼状压，只能 <span class="math inline">\(n!\)</span>
爆枚。那么就不能再带一只 <span class="math inline">\(m\)</span> 了。</p>
<p>假设确定了一个顺序。现在我们要求出前后两只骆驼的最小距离。</p>
<p>考虑 dp，设 <span class="math inline">\(dp_i\)</span> 表示第一只和第
<span class="math inline">\(i\)</span> 只骆驼的最小距离。</p>
<p>转移时，考虑 <span class="math inline">\(j\sim i\)</span>
只骆驼的限制：</p>
<p><span class="math display">\[\forall p\text{ such that
}v_p&lt;\sum_{k=j}^iw_i,dp_i\ge dp_j+l_p\]</span></p>
<p>用人话说就是重量超了就必须隔得够远。</p>
<p>注意到「所有 <span class="math inline">\(v_p\)</span>
小于某个值」的位置会产生限制，那么可以按 <span
class="math inline">\(v\)</span> 从小到大排序，那么每次就是取一段前缀的
<span class="math inline">\(l\)</span>
的最大值，预处理即可。转移时直接二分出产生限制的那段前缀即可。</p>
<p>于是时间复杂度为 <span class="math inline">\(\Theta(n!n^2\log m+m\log
m)\)</span>。</p>
<h3 id="d-1">D</h3>
<p>显然根据 <span class="math inline">\(n\)</span>
的奇偶性会有一个人（设为 X）死命让异或和非 <span
class="math inline">\(0\)</span>，反之亦然。</p>
<p>那么首先如果所有的 <span class="math inline">\(cnt\)</span>
都是偶数，那么另一个人只要模仿 X 的操作就能让 X 必输。</p>
<p>反之，X
可以每次把石子数最多的那袋扔到石子数最多的盘子，那么最后那个盘子的石子数会大于总数的一半，从而使异或和非
<span class="math inline">\(0\)</span> 而获胜。</p>
<p>时间复杂度 <span class="math inline">\(\Theta(n)\)</span> 或 <span
class="math inline">\(\Theta(n\log n)\)</span>。</p>
<h3 id="e-1">E</h3>
<p><del>GameCoder。</del></p>
<p>考虑最后加不动边时的图，可以发现一定是 <span
class="math inline">\(1\)</span> 和 <span
class="math inline">\(n\)</span>
分别在两坨点组成的团里。它有多少条边呢？假设其中一坨有 <span
class="math inline">\(i\)</span> 个点：</p>
<p><span class="math display">\[\begin{aligned}
&amp;\frac{i(i-1)}2+\frac{(n-i)(n-i-1)}2\\
=&amp;\frac{i^2-i+n^2-2in+i^2+i-n}2\\
=&amp;i^2-in+\frac{n^2-n}2
\end{aligned}\]</span></p>
<p>可以发现，如果 <span class="math inline">\(n\)</span>
是奇数，那么最后边数的奇偶性是固定的，胜负已分。</p>
<p>如果 <span class="math inline">\(n\)</span>
是偶数，那么其中一个人就会死命让 <span class="math inline">\(i\)</span>
变成偶数，另一个人死命让 <span class="math inline">\(i\)</span>
变成奇数。</p>
<p>然后反正就是考虑一下镜像操作，结论就是如果先手死命抢偶数，那么当且仅当
<span class="math inline">\(1\)</span> 和 <span
class="math inline">\(n\)</span>
所在连通块大小至少有一个是偶数时先手赢；如果先手死命抢奇数，那么当且仅当有一个是奇数时先手赢。</p>
<h3 id="f-1">F</h3>
<p>这不是我们的 <a
href="https://atcoder.jp/contests/abc327/tasks/abc327_g">ABC327G</a>
吗。</p>
<p>首先你需要发现这个 good 的一坨定义说的是那个图是一个连通二分图。</p>
<p>设 <span class="math inline">\(U\)</span> 为全集，<span
class="math inline">\(f_S\)</span> 表示由 <span
class="math inline">\(S\)</span>
的导出子图组成的<strong>染色</strong>二分图的数量。（这个咋求等下再说）</p>
<p>那么参考那个题的套路，设 <span class="math inline">\(h_S\)</span>
为由 <span class="math inline">\(S\)</span>
的导出子图组成的<strong>连通染色</strong>二分图的数量。</p>
<p>那么容斥一下可以得到：</p>
<p><span class="math display">\[h_S=f_S-\sum_{\substack{T\subset
S\\\min\{S\}\in T}}h_T\cdot f_{S\backslash T}\]</span></p>
<p>而连通二分图只有两种染色方式，那么答案就是 <span
class="math inline">\(\dfrac{h_U}2\)</span>。</p>
<p>然后看怎么求 <span class="math inline">\(f_S\)</span>。</p>
<p>直接暴力枚举染色方案，那么方案数就是 <span
class="math inline">\(2^{e}\)</span>，其中 <span
class="math inline">\(e\)</span> 是连接两个异色点的边数。</p>
<p>但是暴力做是 <span class="math inline">\(\Theta(3^nm)\)</span>
的，过不去。</p>
<p>考虑优化，预处理出 <span class="math inline">\(cnt_{S,i}\)</span>
表示连接 <span class="math inline">\(i\)</span> 和 <span
class="math inline">\(S\)</span> 中任意一点的边数。</p>
<p>那么考虑递推求 <span class="math inline">\(f_S\)</span>。设 <span
class="math inline">\(res_T\)</span> 表示 <span
class="math inline">\(T\)</span> 中点染黑，其它染白，的异色边数。</p>
<p>则有 <span class="math inline">\(res_\varnothing=0\)</span>；设 <span
class="math inline">\(T\ne\varnothing\)</span>，那么令 <span
class="math inline">\(v\in T\)</span>，易得 <span
class="math inline">\(res_T=res_{T\backslash\{v\}}-cnt_{T,v}+cnt_{S\backslash
T,v}\)</span>。</p>
<p>这样就做到了 <span
class="math inline">\(\Theta(3^n+2^nm)\)</span>。</p>
<h2 id="arc106">ARC106</h2>
<h3 id="d-2">D</h3>
<p>注意到 <span
class="math inline">\((a+b)^c=\displaystyle\sum_{i=0}^c\binom
cia^ib^{c-i}\)</span>，令 <span
class="math inline">\(s_i=\displaystyle\sum_{j=1}^na_j^i\)</span>，那么就有</p>
<p><span class="math display">\[\begin{aligned}
&amp;\sum_{i=1}^n\sum_{j=i+1}^n(a_i+a_j)^x\\
=&amp;\sum_{i=1}^n\sum_{j=i+1}^n\sum_{k=0}^x\binom xka_i^ka_j^{x-k}\\
=&amp;\sum_{k=0}^x\binom xk\sum_{i=1}^na_i^k\sum_{j=i+1}^na_j^{x-k}\\
=&amp;\sum_{k=0}^x\binom xk\cdot\frac12(s_ks_{x-k}-s_x)
\end{aligned}\]</span></p>
<p>于是直接就 <span class="math inline">\(\Theta(nk+k^2)\)</span>
做完了。</p>
<h3 id="e-2">E</h3>
<p>想了半天发现是唐题。</p>
<p>你考虑二分，然后直接上 Hall 定理就等价于对于任意一个员工集合 <span
class="math inline">\(S\)</span> 都有：<span
class="math inline">\(S\)</span> 中有员工来工作的天数 <span
class="math inline">\(\ge k\cdot|S|\)</span>。</p>
<p>容斥一下就是 <span class="math inline">\(S\)</span>
里面一个也不来的天数小于某个值。</p>
<p>然后这个对于所有的 <span class="math inline">\(S\)</span>
求可以高维前缀和做到 <span
class="math inline">\(\Theta(n\cdot2^n)\)</span>。</p>
<p>不难发现答案上界是 <span
class="math inline">\(2nk\)</span>，直接预处理每天的考勤情况即可。时间复杂度
<span
class="math inline">\(\Theta(n^2k+nk\log(nk)+n2^n\log(nk))\)</span>。</p>
<h3 id="f-2">F</h3>
<p>首先一个前置知识就是：给定度数序列 <span
class="math inline">\(f\)</span>，可以构成 <span
class="math inline">\(\dfrac{(n-2)!}{\prod (f_i-1)!}\)</span>
棵不同的树。（可以通过 Prüfer 序列证明）</p>
<p>那么如果钦定每个部分的度数 <span
class="math inline">\(f\)</span>，怎么统计不同的洞带来的贡献呢？</p>
<p>从每个部分随便<strong>排列</strong> <span
class="math inline">\(f_i\)</span>
个洞，那么就可以将排列的第一个洞连到父亲，其它的依次连到儿子，可以证明这样是不重不漏的，所以方案数是
<span class="math inline">\(\dfrac{d_i!}{(d_i-f_i)!}\)</span>。</p>
<p>那么就可以列出答案的式子：</p>
<p><span class="math display">\[\begin{aligned}
&amp;\sum_{f\text{ is valid}}\frac{(n-2)!\prod
d_i!}{\prod(d_i-f_i)!(f_i-1)!}\\
=&amp;(n-2)!\left(\prod_{i=1}^nd_i\right)\sum_{f\text{ is
valid}}\prod_{i=1}^n\binom{d_i-1}{f_i-1}\
\end{aligned}\]</span></p>
<p>考虑算右边那坨东西。注意到 <span class="math inline">\(\sum
f_i=2n-2\)</span>，则 <span
class="math inline">\(\sum(f_i-1)=n-2\)</span>，考虑如下问题：</p>
<blockquote>
<p>有 <span class="math inline">\(\sum(d_i-1)\)</span>
个不同的物品，被分成了 <span class="math inline">\(n\)</span> 组，第
<span class="math inline">\(i\)</span> 组有 <span
class="math inline">\(d_i-1\)</span> 个。求从其中选出 <span
class="math inline">\(n-2\)</span> 个物品的方案数。</p>
</blockquote>
<p>一方面，那一坨东西就相当于枚举每组选了多少个，再在每组里面选。</p>
<p>另一方面，直接选和分组再选没区别，所以它等于 <span
class="math inline">\(\dbinom{\sum(d_i-1)}{n-2}\)</span>。</p>
<p>所以答案为：</p>
<p><span
class="math display">\[(n-2)!\left(\prod_{i=1}^nd_i\right)\binom{\sum(d_i-1)}{n-2}\]</span></p>
<p>时间复杂度 <span class="math inline">\(\Theta(n)\)</span>。</p>
<h2 id="arc107">ARC107</h2>
<h3 id="d-3">D</h3>
<p>这个 dp 的思路很妙啊。</p>
<p>设 <span class="math inline">\(dp_{n,k}\)</span> 表示对应的答案，则
<span class="math inline">\(n\ge k\)</span>（否则答案显然为 <span
class="math inline">\(0\)</span>）。</p>
<p>我们讨论：</p>
<ul>
<li>如果这里面有一个 <span class="math inline">\(1\)</span>，那么就是
<span class="math inline">\(dp_{n-1,k-1}\)</span>；</li>
<li>否则不妨把所有元素乘 <span
class="math inline">\(2\)</span>，那么就是 <span
class="math inline">\(dp_{n,2k}\)</span>。</li>
</ul>
<p>然后就做完了。<span class="math inline">\(\Theta(n^2)\)</span>。</p>
<h3 id="e-3">E</h3>
<p>纯结论题啊。。。</p>
<blockquote>
<p>Lemma：对于任意的 <span class="math inline">\(4\le
i,j&lt;n\)</span>，有 <span
class="math inline">\(a_{i,j}=a_{i+1,j+1}\)</span>。</p>
<p><del>Proof</del>：</p>
<p>你发现只要某一行 <span class="math inline">\(&gt;1\)</span>
列的位置出了个 <span class="math inline">\(0\)</span>，后面 <span
class="math inline">\(2\)</span> 列起就一定满足条件了。</p>
<p>然后你发现第 <span class="math inline">\(3\)</span> 行起两个 <span
class="math inline">\(0\)</span> 就最多隔 <span
class="math inline">\(2\)</span> 个位置……</p>
<p>然后就感性理解……</p>
<p>你也可以写个暴力验证一下 <span
class="math inline">\(5\times5\)</span> 的网格……</p>
</blockquote>
<p>然后你爆算前四行前四列就 <span
class="math inline">\(\Theta(n)\)</span> 了……</p>
<h3 id="f-3">F</h3>
<p>抽象网络流。</p>
<p>绝对值搁在那很难受，考虑换个说法：把它们赋一个（相同的）<span
class="math inline">\(1\)</span> 或 <span
class="math inline">\(-1\)</span> 的权值，和的最大值。</p>
<p>这样就舒服多了：最大值就是很能流的样子；连通块的和，其实就是赋的权值全一样；进一步地，就是相邻的两个结点权值必须一样。</p>
<p>那么此时每个结点有三种状态：赋 <span
class="math inline">\(1\)</span>，赋 <span
class="math inline">\(-1\)</span>，被删掉。</p>
<p>考虑最小割，总价值减去最小要移除的贡献：你对一个结点建两个点 <span
class="math inline">\(X,Y\)</span>，连一条边 <span
class="math inline">\(X\to Y\)</span>，然后设 <span
class="math inline">\(Y\)</span> 在 <span
class="math inline">\(S\)</span> 集代表赋 <span
class="math inline">\(1\)</span>，<span class="math inline">\(X\)</span>
在 <span class="math inline">\(T\)</span> 集表示赋 <span
class="math inline">\(-1\)</span>，否则表示删掉。</p>
<p>然后你随便处理一下限制就完了……</p>
<h2 id="arc108">ARC108</h2>
<h3 id="d-4">D</h3>
<p>不妨设 <span class="math inline">\(c_\texttt{ab}=\texttt
a\)</span>，则第一步只能是 <span
class="math inline">\(\texttt{aab}\)</span>。</p>
<p>此时如果 <span class="math inline">\(c_\texttt{aa}=\texttt
a\)</span>，不难发现只能生成 <span
class="math inline">\(\texttt{aaa}\ldots\texttt{ab}\)</span>，答案为
<span class="math inline">\(1\)</span>。</p>
<p>否则还可以生成 <span
class="math inline">\(\texttt{abab}\)</span>，此时讨论：</p>
<ul>
<li>如果 <span class="math inline">\(c_\texttt{ba}=\texttt
a\)</span>，则可得最终串中只需不存在相邻的两个 <span
class="math inline">\(\texttt b\)</span>，答案是斐波那契数列。</li>
<li>如果 <span class="math inline">\(c_\texttt{ba}=\texttt
b\)</span>，则最终串只需有前缀 <span class="math inline">\(\texttt
a\)</span> 和后缀 <span
class="math inline">\(\texttt{ab}\)</span>，答案为 <span
class="math inline">\(2\)</span> 的幂。</li>
</ul>
<p>（以上结论读者自证不难。）</p>
<p>时间复杂度可以做到 <span class="math inline">\(\Theta(\log
n)\)</span>。</p>
<h3 id="e-4">E</h3>
<p>容易发现选出一个位置后左右独立，所以设 <span
class="math inline">\(dp_{l,r}\)</span> 为 <span
class="math inline">\(l-1\)</span> 和 <span
class="math inline">\(r+1\)</span> 都已选中，<span
class="math inline">\([l,r]\)</span> 内都还未选中时，<span
class="math inline">\([l,r]\)</span> 内的期望贡献。</p>
<p>令设 <span class="math inline">\(S_{l,r}=\{p\in \mathbb N\mid l\le
p\le
r,a_{l-1}&lt;a_p&lt;a_{r+1}\}\)</span>，即区间内合法的凳子的集合。</p>
<p>则容易列出转移方程：</p>
<p><span
class="math display">\[dp_{l,r}=\begin{cases}0,&amp;S_{l,r}=\varnothing\\\displaystyle\frac1{|S_{l,r}|}\sum_{i\in
S_{l,r}}1+dp_{l,i-1}+dp_{i+1,r},&amp;S_{l,r}\ne\varnothing\end{cases}\]</span></p>
<p>对于每一项在值域上树状数组优化即可做到 <span
class="math inline">\(\Theta(n^2\log n)\)</span>。</p>
<h3 id="f-4">F</h3>
<p>考虑转换成对于每个 <span class="math inline">\(x\)</span> 计算 <span
class="math inline">\(\mathrm{niceness}\ge x\)</span> 的方案数。</p>
<p>考虑充要条件：上式不成立当且仅当距离 <span class="math inline">\(\ge
x\)</span> 的点对全部异色。</p>
<p>如果直径长度 <span class="math inline">\(&lt;x\)</span>
显然不可能成立。</p>
<p>如果有一个点到直径两端的距离都 <span class="math inline">\(\ge
x\)</span>，那么直径长度也 <span class="math inline">\(\ge
x\)</span>，显然必定成立。</p>
<p>否则一个点最多和一个直径端点距离 <span class="math inline">\(\ge
x\)</span>。考虑距离 <span class="math inline">\(\ge x\)</span>
的点对连一条边，那么不成立相当于这个图被二分图染色。</p>
<p>这个图的形状显然是直径两端各挂了一坨点，加上一坨孤立点。求孤立点数量也是好做的，直接
bfs 一下算一下到直径端点最短距离就行了。</p>
<h2 id="arc109">ARC109</h2>
<h3 id="d-5">D</h3>
<p>人类智慧 + 打表大法 题，无法理解，咕。</p>
<h3 id="e-5">E</h3>
<p>结论很神仙：</p>
<blockquote>
<p>如果两边颜色一样最后肯定全是那种，否则看两个最靠边的连通块哪个离初始点远，远的种颜色就只有那一段。</p>
</blockquote>
<p>证明略。</p>
<p>然后你考虑两边差的是哪一部分，注意到大多数都会被对称掉，那么剩下的就是距离相等的情况，这种情况必然是黑棋得到中间的。</p>
<p>然后再进行一堆 dirty 的推式子，你会得到一个对于钦定的起点的式子。</p>
<p>然后你发现这玩意每一位都是前一位加了一项，直接递推即可。<span
class="math inline">\(\Theta(n)\)</span>。</p>
<h3 id="f-5">F</h3>
<p>没做，咕。</p>
]]></content>
      <categories>
        <category>solutions</category>
        <category>AtCoder</category>
      </categories>
  </entry>
  <entry>
    <title>duel records</title>
    <url>/2024/10/29/duel-%E8%AE%B0/</url>
    <content><![CDATA[<p>感觉最近不 duel
就完全没法集中精力做题。。。<del>我才不会告诉你我写这东西也是因为不想做题。</del></p>
<p>初始 rating：<span
class="math inline">\(\color{orange}{2368}\)</span>。</p>
<h3 id="cf1438c-engineer-artem-2000">#1 <a
href="https://codeforces.com/contest/1438/problem/C">CF1438C Engineer
Artem</a> (*2000)</h3>
<p><span
class="math inline">\({\color{red}\texttt{Lose}},{\color{orange}{}^{2368}}\searrow\color{orange}{}_{2240}\)</span>。</p>
<p>对面那哥们 3min 秒了，我脑子没转过弯来。</p>
<p>其实是唐题，你直接黑白染色，黑点变奇数白点变偶数就完了。</p>
<h3 id="cf698c-lru-2400">#2 <a
href="https://codeforces.com/contest/698/problem/C">CF698C LRU</a>
(*2400)</h3>
<p><span
class="math inline">\({\color{green}\texttt{Win}},{\color{orange}{}_{2240}}\nearrow\color{orange}{}^{2264}\)</span>。</p>
<p>匹配到了 lbw 大神。</p>
<p>直接考虑倒序操作，一个东西进去就不动了。</p>
<p>那么直接状压哪些东西已经进去了，然后 dp 计算其概率，进到 <span
class="math inline">\(k\)</span> 个就统计贡献即可。</p>
<p>注意如果没东西能进（剩下的概率全是 <span
class="math inline">\(0\)</span>）也要返回。<del>因为这个 corner case
挂了 3 发</del></p>
<h3 id="cf350e-wrong-floyd-2200">#3 <a
href="https://codeforces.com/contest/350/problem/E">CF350E Wrong
Floyd</a> (*2200)</h3>
<p><span
class="math inline">\({\color{green}\texttt{Win}},{\color{orange}{}_{2264}}\nearrow\color{orange}{}^{2284}\)</span>。（eps
的优势）</p>
<p><del>考的是你有没有很好地理解 Floyd。</del></p>
<p>首先那 <span class="math inline">\(k\)</span>
个点本身是没用的，直接按 <span class="math inline">\(1\sim k\)</span>
做然后对应过去就行了。</p>
<p><span class="math inline">\(k=n\)</span> 显然是对的。下设 <span
class="math inline">\(k&lt;n\)</span>。</p>
<p>考虑 Floyd 算法，做完 <span class="math inline">\(k\)</span>
轮本质上是计算了以 <span class="math inline">\(1\sim k\)</span>
为中转点时的距离。</p>
<p>先钦定两个点使它们的距离挂掉。注意到 <span class="math inline">\(\le
k\)</span> 的点会使对它进行的那一轮无效，所以不妨选择 <span
class="math inline">\(1,2\)</span>。</p>
<p>显然 <span class="math inline">\(1,2\)</span> 间不能有边。</p>
<p>吗德不会讲了，反正边数上界是 <span
class="math inline">\(m\le\frac{n(n-1)}2-k+1\)</span>，构造是 <span
class="math inline">\(2\sim n\)</span> 连完全图，<span
class="math inline">\(1\)</span> 向 <span
class="math inline">\((k+1)\sim n\)</span>
连边。小于上界随便删点边即可。</p>
<h3 id="cf1059e-split-the-tree-2400">#4 <a
href="https://codeforces.com/contest/1059/problem/E">CF1059E Split the
Tree</a> (*2400)</h3>
<p><span
class="math inline">\({\color{red}\texttt{Lose}},{\color{orange}{}^{2284}}\searrow\color{orange}{}_{2191}\)</span>。（比对面晚
eps 分钟交，结果还挂了好几发。）</p>
<p>唐题，咋想了半天写了半天。</p>
<p>实际上一个点被盖多次也可以把一些链缩回去来达到恰好一次。所以可以当每个点<strong>至少覆盖一次</strong>。</p>
<p>注意到如果一个点为一条链的下端点，那上端点肯定越往上越优。这个上端点直接倍增啥的算下就行了。</p>
<p>然后易证从下往上贪就是对的。（一个点没被它的子树盖住就必须从它往上盖）</p>
<h3 id="cf1628d2-game-on-sum-hard-version-2400">#5 <a
href="https://codeforces.com/contest/1628/problem/D2">CF1628D2 Game on
Sum (Hard Version)</a> (*2400)</h3>
<p><span
class="math inline">\({\color{green}\texttt{Win}},{\color{orange}{}_{2191}}\nearrow\color{orange}{}^{2204}\)</span>。</p>
<p>对面好像是个题解管理……？还跟我互关了……？上一场的对手还凑热闹来交这题了……？</p>
<p>首先 <span class="math inline">\(k\)</span>
没用，单纯乘了个系数。可以当 <span class="math inline">\(k=1\)</span>
做。</p>
<p>考虑 dp，<span class="math inline">\(dp_{n,m}\)</span> 表示 <span
class="math inline">\(n,m\)</span> 的答案。</p>
<p>不难写出转移</p>
<p><span class="math display">\[dp_{n,m}=\max_{0\le x\le
1}\min\{dp_{n-1,m-1}+x,dp_{n-1,m}-x\}\]</span></p>
<p>（其中 <span class="math inline">\(x\)</span> 是实数，如果 <span
class="math inline">\(m&lt;0\)</span> 或 <span
class="math inline">\(m&gt;n\)</span> 就是 <span
class="math inline">\(+\infty\)</span>。）</p>
<p>然后就能过 easy ver 了。</p>
<p>考虑优化，不难发现 <span
class="math inline">\(dp_{n,0}=0,dp_{n,n}=n\)</span>。</p>
<p>然后看转移式：如果 <span
class="math inline">\(dp_{n-1,m}-dp_{n-1,m-1}\le 2\)</span>，那么显然有
<span
class="math inline">\(dp_{n,m}=\dfrac12(dp_{n-1,m}+dp_{n-1,m-1})\)</span>。</p>
<p>然后这个条件是成立的，证明留作习题。</p>
<p>那么考虑计算每个 <span class="math inline">\((i,i)\)</span>
对答案的贡献（实际上还有 <span class="math inline">\((i,0)\)</span>
的，但是因为是 <span class="math inline">\(0\)</span> 可以忽略掉）。</p>
<p>那么转化成：<span class="math inline">\((i,j)\)</span> 可以走到 <span
class="math inline">\((i-1,j)\)</span> 或 <span
class="math inline">\((i-1,j-1)\)</span>，求 <span
class="math inline">\((n,m)\)</span> 首次走到 <span
class="math inline">\(x=y\)</span> 的位置是 <span
class="math inline">\((i,i)\)</span> 的方案数。</p>
<p>这玩意显然就是一堆组合数，贡献就乘一个 <span
class="math inline">\(2\)</span> 的负几次方就行。时间复杂度 <span
class="math inline">\(\Theta(n)\)</span>。</p>
]]></content>
      <categories>
        <category>solutions</category>
        <category>CodeForces</category>
      </categories>
  </entry>
</search>
