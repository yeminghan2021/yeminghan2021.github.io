<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CSP 2024</title>
    <url>/2024/09/27/CSP-2024/</url>
    <content><![CDATA[<p>GD-S01190/GD-S00489。</p>
<h2 id="day--2omegasim--omega">Day <span
class="math inline">\(-2\omega\sim -\omega\)</span></h2>
<p>开学了。正式成为了高一 OIer。回学校上了一周，然后就停课了。</p>
<p>去打了高联。有个唐诗做一试 T1 时在草稿纸上写下了 <span
class="math inline">\(8^{9^{2024}}=2^{27^{2024}}\)</span>，我不说是谁。椭圆双曲线啥的都忘光了。二试做完
T1T3 就对着几何题罚坐了。</p>
<p>CSP 模拟赛暴打 110pts，遗言丁真鉴定为原形毕露了。</p>
<p>如此成绩，如何 CSP？如此成绩，如何 CSP？如此成绩，如何 CSP？</p>
<h2 id="day--omega">Day <span
class="math inline">\(-\omega\)</span></h2>
<p>初赛。</p>
<p>没啥好说的。1h 速通掉了。完善程序 <span
class="math inline">\(9\)</span> 个 <span class="math inline">\(\texttt
A\)</span> 咋搞的。</p>
<p>在草稿纸上默写了《山东车牌歌》和元素周期表。<del>后来发现「鲁 M
滨州」的「滨」写成不带三点水的了</del></p>
<p>没有对答案，<del>毕竟三年前过今年不过是不是。。。</del></p>
<h2 id="day--omegasim-0">Day <span class="math inline">\(-\omega\sim
0\)</span></h2>
<p>最近 CFAT 状态经常爆炸。在上 GM 7 个月后成功地掉到了 IM。在上 3 Dan 5
个月后成功的掉到了黄名。</p>
<p>国庆模拟赛。爆！爆！爆！摆！摆！摆！魔怔！</p>
<p>比赛前几天疯狂摆烂。</p>
<p>发现高联 2= 了，但是是 2= rk11，唉 T1T2 不挂就可能 1= 了。</p>
<p>Day <span class="math inline">\(0\)</span> 开始当预言家，押了
greedy/dp/tree/ds。</p>
<h2 id="day-1">Day <span class="math inline">\(1\)</span></h2>
<p>发现考场在七楼，气喘吁吁。</p>
<p>解压密码是随机字符串。</p>
<p>开场开了个 NOI linux，可以传文件，爽！</p>
<p>看 T1。<span class="math inline">\(\max cnt\)</span> 秒了。此时是
15min。</p>
<p>看 T2。超速一定是段区间，二分加贪心秒了。此时是 45min。</p>
<p>看 T3。一眼 <span class="math inline">\(n^2\)</span>
dp，然后线段树优化完了。写写写，过样例了，此时是 1h30m。</p>
<p>把前三题扔到了虚拟机上跑。不是为啥 <code>ulimit -v</code> 和
<code>-fsanitize=address</code> 一起用会爆啊？浪费 5min，急了，把
<code>fsanitize</code> 删了。</p>
<p>看 T4。不会。</p>
<p>回去给 T3 造了组极限。我擦跑了 1.5s？我擦线段树原来是 <span
class="math inline">\(\Theta(Tn\log V)\)</span>
的？发现可以线性，改改改，0.2s 轻松通过，此时是 2h15m。</p>
<p>编了半天编出了 T4 的 <span class="math inline">\(\Theta(Tn\log
n)\)</span>，写写写，样例 2 过，样例 3 过，样例 4……WA 了？</p>
<p>发现假了。此时是 3h20m。</p>
<p>尝试改，发现要多一只 <span
class="math inline">\(\log\)</span>。不管了开改，过了所有样例。</p>
<p>测了一下 T4 效率，发现 <span class="math inline">\(T=16\)</span> 可以
0.5s 轻松跑过？</p>
<p>最后 15min 开摆了。</p>
<p>估分 <span class="math inline">\(100+100+100+76=376\)</span>。</p>
<hr />
<p>出来发现一车人 AK 了。又双叒叕被爆了 T_T</p>
<p>昨天预言的似乎只有 T1 比较准。</p>
<p>听说勾 7 线要 300+？？？不是今年真比去年简单得多吗。</p>
<h2 id="day-2simomega">Day <span
class="math inline">\(2\sim\omega\)</span></h2>
<p>Day <span class="math inline">\(2\)</span> ARC 雪耻，回橙！A
赛后补出来很好玩，B 很套路，C 很聪明，D 很 cn，E 看不懂题解。</p>
<p>Day <span class="math inline">\(3\)</span> vp 了昨天的 global
round。打得很抽象。</p>
<p><img
src="https://cdn.luogu.com.cn/upload/image_hosting/h0d9pmrz.png" /></p>
<p>开始玩 duel，结果分全都掉没了。。。</p>
<h2 id="day-omega">Day <span class="math inline">\(\omega\)</span></h2>
<p>最终分 <span class="math inline">\(376\)</span>，没挂！</p>
<p>小胜一把。</p>
<p>NOIP &amp; 省选 RP++！</p>
<hr />
<p>总结：</p>
<ul>
<li>一定要测蓟县数据！一定要测蓟县数据！一定要测蓟县数据！</li>
<li>假了别急！假了别急！假了别急！</li>
</ul>
]]></content>
      <categories>
        <category>游记</category>
        <category>2024-2025</category>
      </categories>
  </entry>
  <entry>
    <title>duel records</title>
    <url>/2024/10/29/duel-%E8%AE%B0/</url>
    <content><![CDATA[<p>感觉最近不 duel
就完全没法集中精力做题。。。<del>我才不会告诉你我写这东西也是因为不想做题。</del></p>
<p>初始 rating：<span
class="math inline">\(\color{orange}{2368}\)</span>。</p>
<h3 id="cf1438c-engineer-artem-2000">#1 <a
href="https://codeforces.com/contest/1438/problem/C">CF1438C Engineer
Artem</a> (*2000)</h3>
<p><span
class="math inline">\({\color{red}\texttt{Lose}},{\color{orange}{}^{2368}}\searrow\color{orange}{}_{2240}\)</span>。</p>
<p>对面那哥们 3min 秒了，我脑子没转过弯来。</p>
<p>其实是唐题，你直接黑白染色，黑点变奇数白点变偶数就完了。</p>
<h3 id="cf698c-lru-2400">#2 <a
href="https://codeforces.com/contest/698/problem/C">CF698C LRU</a>
(*2400)</h3>
<p><span
class="math inline">\({\color{green}\texttt{Win}},{\color{orange}{}_{2240}}\nearrow\color{orange}{}^{2264}\)</span>。</p>
<p>匹配到了 lbw 大神。</p>
<p>直接考虑倒序操作，一个东西进去就不动了。</p>
<p>那么直接状压哪些东西已经进去了，然后 dp 计算其概率，进到 <span
class="math inline">\(k\)</span> 个就统计贡献即可。</p>
<p>注意如果没东西能进（剩下的概率全是 <span
class="math inline">\(0\)</span>）也要返回。<del>因为这个 corner case
挂了 3 发</del></p>
<h3 id="cf350e-wrong-floyd-2200">#3 <a
href="https://codeforces.com/contest/350/problem/E">CF350E Wrong
Floyd</a> (*2200)</h3>
<p><span
class="math inline">\({\color{green}\texttt{Win}},{\color{orange}{}_{2264}}\nearrow\color{orange}{}^{2284}\)</span>。（eps
的优势）</p>
<p><del>考的是你有没有很好地理解 Floyd。</del></p>
<p>首先那 <span class="math inline">\(k\)</span>
个点本身是没用的，直接按 <span class="math inline">\(1\sim k\)</span>
做然后对应过去就行了。</p>
<p><span class="math inline">\(k=n\)</span> 显然是对的。下设 <span
class="math inline">\(k&lt;n\)</span>。</p>
<p>考虑 Floyd 算法，做完 <span class="math inline">\(k\)</span>
轮本质上是计算了以 <span class="math inline">\(1\sim k\)</span>
为中转点时的距离。</p>
<p>先钦定两个点使它们的距离挂掉。注意到 <span class="math inline">\(\le
k\)</span> 的点会使对它进行的那一轮无效，所以不妨选择 <span
class="math inline">\(1,2\)</span>。</p>
<p>显然 <span class="math inline">\(1,2\)</span> 间不能有边。</p>
<p>吗德不会讲了，反正边数上界是 <span
class="math inline">\(m\le\frac{n(n-1)}2-k+1\)</span>，构造是 <span
class="math inline">\(2\sim n\)</span> 连完全图，<span
class="math inline">\(1\)</span> 向 <span
class="math inline">\((k+1)\sim n\)</span>
连边。小于上界随便删点边即可。</p>
<h3 id="cf1059e-split-the-tree-2400">#4 <a
href="https://codeforces.com/contest/1059/problem/E">CF1059E Split the
Tree</a> (*2400)</h3>
<p><span
class="math inline">\({\color{red}\texttt{Lose}},{\color{orange}{}^{2284}}\searrow\color{orange}{}_{2191}\)</span>。（比对面晚
eps 分钟交，结果还挂了好几发。）</p>
<p>唐题，咋想了半天写了半天。</p>
<p>实际上一个点被盖多次也可以把一些链缩回去来达到恰好一次。所以可以当每个点<strong>至少覆盖一次</strong>。</p>
<p>注意到如果一个点为一条链的下端点，那上端点肯定越往上越优。这个上端点直接倍增啥的算下就行了。</p>
<p>然后易证从下往上贪就是对的。（一个点没被它的子树盖住就必须从它往上盖）</p>
<h3 id="cf1628d2-game-on-sum-hard-version-2400">#5 <a
href="https://codeforces.com/contest/1628/problem/D2">CF1628D2 Game on
Sum (Hard Version)</a> (*2400)</h3>
<p><span
class="math inline">\({\color{green}\texttt{Win}},{\color{orange}{}_{2191}}\nearrow\color{orange}{}^{2204}\)</span>。</p>
<p>对面好像是个题解管理……？还跟我互关了……？上一场的对手还凑热闹来交这题了……？</p>
<p>首先 <span class="math inline">\(k\)</span>
没用，单纯乘了个系数。可以当 <span class="math inline">\(k=1\)</span>
做。</p>
<p>考虑 dp，<span class="math inline">\(dp_{n,m}\)</span> 表示 <span
class="math inline">\(n,m\)</span> 的答案。</p>
<p>不难写出转移</p>
<p><span class="math display">\[dp_{n,m}=\max_{0\le x\le
1}\min\{dp_{n-1,m-1}+x,dp_{n-1,m}-x\}\]</span></p>
<p>（其中 <span class="math inline">\(x\)</span> 是实数，如果 <span
class="math inline">\(m&lt;0\)</span> 或 <span
class="math inline">\(m&gt;n\)</span> 就是 <span
class="math inline">\(+\infty\)</span>。）</p>
<p>然后就能过 easy ver 了。</p>
<p>考虑优化，不难发现 <span
class="math inline">\(dp_{n,0}=0,dp_{n,n}=n\)</span>。</p>
<p>然后看转移式：如果 <span
class="math inline">\(dp_{n-1,m}-dp_{n-1,m-1}\le 2\)</span>，那么显然有
<span
class="math inline">\(dp_{n,m}=\dfrac12(dp_{n-1,m}+dp_{n-1,m-1})\)</span>。</p>
<p>然后这个条件是成立的，证明留作习题。</p>
<p>那么考虑计算每个 <span class="math inline">\((i,i)\)</span>
对答案的贡献（实际上还有 <span class="math inline">\((i,0)\)</span>
的，但是因为是 <span class="math inline">\(0\)</span> 可以忽略掉）。</p>
<p>那么转化成：<span class="math inline">\((i,j)\)</span> 可以走到 <span
class="math inline">\((i-1,j)\)</span> 或 <span
class="math inline">\((i-1,j-1)\)</span>，求 <span
class="math inline">\((n,m)\)</span> 首次走到 <span
class="math inline">\(x=y\)</span> 的位置是 <span
class="math inline">\((i,i)\)</span> 的方案数。</p>
<p>这玩意显然就是一堆组合数，贡献就乘一个 <span
class="math inline">\(2\)</span> 的负几次方就行。时间复杂度 <span
class="math inline">\(\Theta(n)\)</span>。</p>
]]></content>
      <categories>
        <category>solutions</category>
        <category>CodeForces</category>
      </categories>
  </entry>
  <entry>
    <title>ARC 瞎做</title>
    <url>/2024/09/27/ARC-%E7%9E%8E%E5%81%9A/</url>
    <content><![CDATA[<p>范围：<span
class="math inline">\(\text{ARC}[\ge104][\text{C|D|E|F}]\land\text{Difficulty}\ge1600\)</span>。</p>
<h2 id="arc104">ARC104</h2>
<h3 id="c">C</h3>
<p>可以发现一段极小的合法区间必然是这样的一个形式：</p>
<p><span
class="math display">\[[x,x+y],[x+1,x+y+1],\ldots,[x+y-1,x+2y-1].\]</span></p>
<p>然后你直接判区间合法 dp 一下就行了。细节有点多。</p>
<h3 id="d">D</h3>
<p>考虑 dp，令 <span class="math inline">\(dp_{i,j,k}\)</span>
表示考虑了 <span class="math inline">\(1\sim i\)</span>
的所有数字，一共选了 <span class="math inline">\(j\)</span> 个，和为
<span class="math inline">\(k\)</span> 的方案数。</p>
<p><del>直接做是 <span class="math inline">\(n^7\)</span>
的过牛魔啊。。。</del></p>
<p>首先前缀和优化砍掉一个 <span
class="math inline">\(n\)</span>。然后你发现状态数就是这么多，必须优化状态数。</p>
<p>考虑求 <span class="math inline">\(x\)</span> 的答案，不妨整体平移
<span class="math inline">\(x\)</span>，那么就是 <span
class="math inline">\(1-x\)</span> 到 <span
class="math inline">\(n-x\)</span> 各 <span
class="math inline">\(k\)</span> 个，选出若干个和为 <span
class="math inline">\(0\)</span>。</p>
<p>那么设 <span class="math inline">\(dp_{i,j}\)</span> 表示考虑了 <span
class="math inline">\((1-x)\sim(i-x)\)</span> 的所有数，和为 <span
class="math inline">\(j\)</span> 的方案数。那么求单个数的答案是 <span
class="math inline">\(n^4\)</span>
的，<del>常数小也许能冲过去？</del></p>
<p>考虑正负分开算，设 <span class="math inline">\(dp_{i,j}\)</span>
表示考虑 <span class="math inline">\(1\sim i\)</span> 的所有数，和为
<span class="math inline">\(j\)</span> 的方案数。</p>
<p>那么可以发现 <span class="math inline">\(x\)</span> 的答案就是 <span
class="math inline">\(\displaystyle(k+1)\sum_{i=0}^\infty
dp_{x-1,i}\cdot
dp_{n-x,i}\)</span>。（就是正数总和等于负数绝对值总和）</p>
<p>那么时间复杂度为 <span
class="math inline">\(\Theta(n^4)\)</span>。</p>
<h3 id="e">E</h3>
<p>厉害题。看了题解才会。</p>
<p>考虑爆枚这 <span class="math inline">\(n\)</span>
个数的大小关系（<strong>可能相等</strong>），然后算出它的 LIS
长度，那么转化为求方案数。</p>
<p>发现问题变成了：</p>
<blockquote>
<p>给出 <span class="math inline">\(A\)</span>，求满足 <span
class="math inline">\(1\le a_i\le A_i\)</span>
的<strong>严格上升</strong>序列 <span class="math inline">\(a\)</span>
的数量。</p>
</blockquote>
<p>不妨假设 <span class="math inline">\(A\)</span> 不降，<span
class="math inline">\(A_0=0\)</span>。</p>
<p>设 <span class="math inline">\(dp_{i,j}\)</span> 表示将 <span
class="math inline">\(1\sim a_j\)</span> 填在 <span
class="math inline">\([1,A_i]\)</span> 中的方案数。</p>
<p>那么有转移：</p>
<p><span class="math display">\[dp_{i+1,j+k}\gets
\binom{A_{i+1}-A_i}k\cdot dp_{i,j}.\]</span></p>
<p>由于 <span class="math inline">\(k\)</span> 很小直接 <span
class="math inline">\(\Theta(k)\)</span> 算组合数即可。</p>
<p>然后就做完了。时间是 <span
class="math inline">\(\Theta(n^n\cdot\mathrm{poly}(n))\)</span>，但是多几只
<span class="math inline">\(n\)</span> 也随便冲。</p>
<h3 id="f">F</h3>
<p>不妨设 <span class="math inline">\(-1\)</span>
的位置有一个无限高的，不影响。</p>
<p>你考虑 <span class="math inline">\(p_i=j\)</span> 的限制就是 <span
class="math inline">\(p_j&gt;p_i\)</span> 且【<span
class="math inline">\(i&lt;k&lt;j\)</span> 时 <span
class="math inline">\(p_j\le p_i\)</span>】。</p>
<p>然后你考虑把笛卡尔树建出来，那么就是左儿子小于等于它的，右儿子小于它的。</p>
<p>那么枚举根就变成两个区间的子问题了，dp 即可。（设 <span
class="math inline">\(dp_{l,r,v}\)</span> 表示 <span
class="math inline">\([l,r]\)</span> 内，值域为 <span
class="math inline">\([1,v]\)</span> 的方案数。）</p>
<p>注意到无论你怎么限制也只需要 <span class="math inline">\(n\)</span>
的值域，所以状态数为 <span
class="math inline">\(\Theta(n^3)\)</span>，转移只需枚举根，所以时间复杂度为
<span class="math inline">\(\Theta(n^4)\)</span>。</p>
<h2 id="arc105">ARC105</h2>
<h3 id="c-1">C</h3>
<p>首先这题很难把骆驼状压，只能 <span class="math inline">\(n!\)</span>
爆枚。那么就不能再带一只 <span class="math inline">\(m\)</span> 了。</p>
<p>假设确定了一个顺序。现在我们要求出前后两只骆驼的最小距离。</p>
<p>考虑 dp，设 <span class="math inline">\(dp_i\)</span> 表示第一只和第
<span class="math inline">\(i\)</span> 只骆驼的最小距离。</p>
<p>转移时，考虑 <span class="math inline">\(j\sim i\)</span>
只骆驼的限制：</p>
<p><span class="math display">\[\forall p\text{ such that
}v_p&lt;\sum_{k=j}^iw_i,dp_i\ge dp_j+l_p\]</span></p>
<p>用人话说就是重量超了就必须隔得够远。</p>
<p>注意到「所有 <span class="math inline">\(v_p\)</span>
小于某个值」的位置会产生限制，那么可以按 <span
class="math inline">\(v\)</span> 从小到大排序，那么每次就是取一段前缀的
<span class="math inline">\(l\)</span>
的最大值，预处理即可。转移时直接二分出产生限制的那段前缀即可。</p>
<p>于是时间复杂度为 <span class="math inline">\(\Theta(n!n^2\log m+m\log
m)\)</span>。</p>
<h3 id="d-1">D</h3>
<p>显然根据 <span class="math inline">\(n\)</span>
的奇偶性会有一个人（设为 X）死命让异或和非 <span
class="math inline">\(0\)</span>，反之亦然。</p>
<p>那么首先如果所有的 <span class="math inline">\(cnt\)</span>
都是偶数，那么另一个人只要模仿 X 的操作就能让 X 必输。</p>
<p>反之，X
可以每次把石子数最多的那袋扔到石子数最多的盘子，那么最后那个盘子的石子数会大于总数的一半，从而使异或和非
<span class="math inline">\(0\)</span> 而获胜。</p>
<p>时间复杂度 <span class="math inline">\(\Theta(n)\)</span> 或 <span
class="math inline">\(\Theta(n\log n)\)</span>。</p>
<h3 id="e-1">E</h3>
<p><del>GameCoder。</del></p>
<p>考虑最后加不动边时的图，可以发现一定是 <span
class="math inline">\(1\)</span> 和 <span
class="math inline">\(n\)</span>
分别在两坨点组成的团里。它有多少条边呢？假设其中一坨有 <span
class="math inline">\(i\)</span> 个点：</p>
<p><span class="math display">\[\begin{aligned}
&amp;\frac{i(i-1)}2+\frac{(n-i)(n-i-1)}2\\
=&amp;\frac{i^2-i+n^2-2in+i^2+i-n}2\\
=&amp;i^2-in+\frac{n^2-n}2
\end{aligned}\]</span></p>
<p>可以发现，如果 <span class="math inline">\(n\)</span>
是奇数，那么最后边数的奇偶性是固定的，胜负已分。</p>
<p>如果 <span class="math inline">\(n\)</span>
是偶数，那么其中一个人就会死命让 <span class="math inline">\(i\)</span>
变成偶数，另一个人死命让 <span class="math inline">\(i\)</span>
变成奇数。</p>
<p>然后反正就是考虑一下镜像操作，结论就是如果先手死命抢偶数，那么当且仅当
<span class="math inline">\(1\)</span> 和 <span
class="math inline">\(n\)</span>
所在连通块大小至少有一个是偶数时先手赢；如果先手死命抢奇数，那么当且仅当有一个是奇数时先手赢。</p>
<h3 id="f-1">F</h3>
<p>这不是我们的 <a
href="https://atcoder.jp/contests/abc327/tasks/abc327_g">ABC327G</a>
吗。</p>
<p>首先你需要发现这个 good 的一坨定义说的是那个图是一个连通二分图。</p>
<p>设 <span class="math inline">\(U\)</span> 为全集，<span
class="math inline">\(f_S\)</span> 表示由 <span
class="math inline">\(S\)</span>
的导出子图组成的<strong>染色</strong>二分图的数量。（这个咋求等下再说）</p>
<p>那么参考那个题的套路，设 <span class="math inline">\(h_S\)</span>
为由 <span class="math inline">\(S\)</span>
的导出子图组成的<strong>连通染色</strong>二分图的数量。</p>
<p>那么容斥一下可以得到：</p>
<p><span class="math display">\[h_S=f_S-\sum_{\substack{T\subset
S\\\min\{S\}\in T}}h_T\cdot f_{S\backslash T}\]</span></p>
<p>而连通二分图只有两种染色方式，那么答案就是 <span
class="math inline">\(\dfrac{h_U}2\)</span>。</p>
<p>然后看怎么求 <span class="math inline">\(f_S\)</span>。</p>
<p>直接暴力枚举染色方案，那么方案数就是 <span
class="math inline">\(2^{e}\)</span>，其中 <span
class="math inline">\(e\)</span> 是连接两个异色点的边数。</p>
<p>但是暴力做是 <span class="math inline">\(\Theta(3^nm)\)</span>
的，过不去。</p>
<p>考虑优化，预处理出 <span class="math inline">\(cnt_{S,i}\)</span>
表示连接 <span class="math inline">\(i\)</span> 和 <span
class="math inline">\(S\)</span> 中任意一点的边数。</p>
<p>那么考虑递推求 <span class="math inline">\(f_S\)</span>。设 <span
class="math inline">\(res_T\)</span> 表示 <span
class="math inline">\(T\)</span> 中点染黑，其它染白，的异色边数。</p>
<p>则有 <span class="math inline">\(res_\varnothing=0\)</span>；设 <span
class="math inline">\(T\ne\varnothing\)</span>，那么令 <span
class="math inline">\(v\in T\)</span>，易得 <span
class="math inline">\(res_T=res_{T\backslash\{v\}}-cnt_{T,v}+cnt_{S\backslash
T,v}\)</span>。</p>
<p>这样就做到了 <span
class="math inline">\(\Theta(3^n+2^nm)\)</span>。</p>
<h2 id="arc106">ARC106</h2>
<h3 id="d-2">D</h3>
<p>注意到 <span
class="math inline">\((a+b)^c=\displaystyle\sum_{i=0}^c\binom
cia^ib^{c-i}\)</span>，令 <span
class="math inline">\(s_i=\displaystyle\sum_{j=1}^na_j^i\)</span>，那么就有</p>
<p><span class="math display">\[\begin{aligned}
&amp;\sum_{i=1}^n\sum_{j=i+1}^n(a_i+a_j)^x\\
=&amp;\sum_{i=1}^n\sum_{j=i+1}^n\sum_{k=0}^x\binom xka_i^ka_j^{x-k}\\
=&amp;\sum_{k=0}^x\binom xk\sum_{i=1}^na_i^k\sum_{j=i+1}^na_j^{x-k}\\
=&amp;\sum_{k=0}^x\binom xk\cdot\frac12(s_ks_{x-k}-s_x)
\end{aligned}\]</span></p>
<p>于是直接就 <span class="math inline">\(\Theta(nk+k^2)\)</span>
做完了。</p>
<h3 id="e-2">E</h3>
<p>想了半天发现是唐题。</p>
<p>你考虑二分，然后直接上 Hall 定理就等价于对于任意一个员工集合 <span
class="math inline">\(S\)</span> 都有：<span
class="math inline">\(S\)</span> 中有员工来工作的天数 <span
class="math inline">\(\ge k\cdot|S|\)</span>。</p>
<p>容斥一下就是 <span class="math inline">\(S\)</span>
里面一个也不来的天数小于某个值。</p>
<p>然后这个对于所有的 <span class="math inline">\(S\)</span>
求可以高维前缀和做到 <span
class="math inline">\(\Theta(n\cdot2^n)\)</span>。</p>
<p>不难发现答案上界是 <span
class="math inline">\(2nk\)</span>，直接预处理每天的考勤情况即可。时间复杂度
<span
class="math inline">\(\Theta(n^2k+nk\log(nk)+n2^n\log(nk))\)</span>。</p>
<h3 id="f-2">F</h3>
<p>首先一个前置知识就是：给定度数序列 <span
class="math inline">\(f\)</span>，可以构成 <span
class="math inline">\(\dfrac{(n-2)!}{\prod (f_i-1)!}\)</span>
棵不同的树。（可以通过 Prüfer 序列证明）</p>
<p>那么如果钦定每个部分的度数 <span
class="math inline">\(f\)</span>，怎么统计不同的洞带来的贡献呢？</p>
<p>从每个部分随便<strong>排列</strong> <span
class="math inline">\(f_i\)</span>
个洞，那么就可以将排列的第一个洞连到父亲，其它的依次连到儿子，可以证明这样是不重不漏的，所以方案数是
<span class="math inline">\(\dfrac{d_i!}{(d_i-f_i)!}\)</span>。</p>
<p>那么就可以列出答案的式子：</p>
<p><span class="math display">\[\begin{aligned}
&amp;\sum_{f\text{ is valid}}\frac{(n-2)!\prod
d_i!}{\prod(d_i-f_i)!(f_i-1)!}\\
=&amp;(n-2)!\left(\prod_{i=1}^nd_i\right)\sum_{f\text{ is
valid}}\prod_{i=1}^n\binom{d_i-1}{f_i-1}\
\end{aligned}\]</span></p>
<p>考虑算右边那坨东西。注意到 <span class="math inline">\(\sum
f_i=2n-2\)</span>，则 <span
class="math inline">\(\sum(f_i-1)=n-2\)</span>，考虑如下问题：</p>
<blockquote>
<p>有 <span class="math inline">\(\sum(d_i-1)\)</span>
个不同的物品，被分成了 <span class="math inline">\(n\)</span> 组，第
<span class="math inline">\(i\)</span> 组有 <span
class="math inline">\(d_i-1\)</span> 个。求从其中选出 <span
class="math inline">\(n-2\)</span> 个物品的方案数。</p>
</blockquote>
<p>一方面，那一坨东西就相当于枚举每组选了多少个，再在每组里面选。</p>
<p>另一方面，直接选和分组再选没区别，所以它等于 <span
class="math inline">\(\dbinom{\sum(d_i-1)}{n-2}\)</span>。</p>
<p>所以答案为：</p>
<p><span
class="math display">\[(n-2)!\left(\prod_{i=1}^nd_i\right)\binom{\sum(d_i-1)}{n-2}\]</span></p>
<p>时间复杂度 <span class="math inline">\(\Theta(n)\)</span>。</p>
<h2 id="arc107">ARC107</h2>
<h3 id="d-3">D</h3>
<p>这个 dp 的思路很妙啊。</p>
<p>设 <span class="math inline">\(dp_{n,k}\)</span> 表示对应的答案，则
<span class="math inline">\(n\ge k\)</span>（否则答案显然为 <span
class="math inline">\(0\)</span>）。</p>
<p>我们讨论：</p>
<ul>
<li>如果这里面有一个 <span class="math inline">\(1\)</span>，那么就是
<span class="math inline">\(dp_{n-1,k-1}\)</span>；</li>
<li>否则不妨把所有元素乘 <span
class="math inline">\(2\)</span>，那么就是 <span
class="math inline">\(dp_{n,2k}\)</span>。</li>
</ul>
<p>然后就做完了。<span class="math inline">\(\Theta(n^2)\)</span>。</p>
<h3 id="e-3">E</h3>
<p>纯结论题啊。。。</p>
<blockquote>
<p>Lemma：对于任意的 <span class="math inline">\(4\le
i,j&lt;n\)</span>，有 <span
class="math inline">\(a_{i,j}=a_{i+1,j+1}\)</span>。</p>
<p><del>Proof</del>：</p>
<p>你发现只要某一行 <span class="math inline">\(&gt;1\)</span>
列的位置出了个 <span class="math inline">\(0\)</span>，后面 <span
class="math inline">\(2\)</span> 列起就一定满足条件了。</p>
<p>然后你发现第 <span class="math inline">\(3\)</span> 行起两个 <span
class="math inline">\(0\)</span> 就最多隔 <span
class="math inline">\(2\)</span> 个位置……</p>
<p>然后就感性理解……</p>
<p>你也可以写个暴力验证一下 <span
class="math inline">\(5\times5\)</span> 的网格……</p>
</blockquote>
<p>然后你爆算前四行前四列就 <span
class="math inline">\(\Theta(n)\)</span> 了……</p>
<h3 id="f-3">F</h3>
<p>抽象网络流。</p>
<p>绝对值搁在那很难受，考虑换个说法：把它们赋一个（相同的）<span
class="math inline">\(1\)</span> 或 <span
class="math inline">\(-1\)</span> 的权值，和的最大值。</p>
<p>这样就舒服多了：最大值就是很能流的样子；连通块的和，其实就是赋的权值全一样；进一步地，就是相邻的两个结点权值必须一样。</p>
<p>那么此时每个结点有三种状态：赋 <span
class="math inline">\(1\)</span>，赋 <span
class="math inline">\(-1\)</span>，被删掉。</p>
<p>考虑最小割，总价值减去最小要移除的贡献：你对一个结点建两个点 <span
class="math inline">\(X,Y\)</span>，连一条边 <span
class="math inline">\(X\to Y\)</span>，然后设 <span
class="math inline">\(Y\)</span> 在 <span
class="math inline">\(S\)</span> 集代表赋 <span
class="math inline">\(1\)</span>，<span class="math inline">\(X\)</span>
在 <span class="math inline">\(T\)</span> 集表示赋 <span
class="math inline">\(-1\)</span>，否则表示删掉。</p>
<p>然后你随便处理一下限制就完了……</p>
<h2 id="arc108">ARC108</h2>
<h3 id="d-4">D</h3>
<p>不妨设 <span class="math inline">\(c_\texttt{ab}=\texttt
a\)</span>，则第一步只能是 <span
class="math inline">\(\texttt{aab}\)</span>。</p>
<p>此时如果 <span class="math inline">\(c_\texttt{aa}=\texttt
a\)</span>，不难发现只能生成 <span
class="math inline">\(\texttt{aaa}\ldots\texttt{ab}\)</span>，答案为
<span class="math inline">\(1\)</span>。</p>
<p>否则还可以生成 <span
class="math inline">\(\texttt{abab}\)</span>，此时讨论：</p>
<ul>
<li>如果 <span class="math inline">\(c_\texttt{ba}=\texttt
a\)</span>，则可得最终串中只需不存在相邻的两个 <span
class="math inline">\(\texttt b\)</span>，答案是斐波那契数列。</li>
<li>如果 <span class="math inline">\(c_\texttt{ba}=\texttt
b\)</span>，则最终串只需有前缀 <span class="math inline">\(\texttt
a\)</span> 和后缀 <span
class="math inline">\(\texttt{ab}\)</span>，答案为 <span
class="math inline">\(2\)</span> 的幂。</li>
</ul>
<p>（以上结论读者自证不难。）</p>
<p>时间复杂度可以做到 <span class="math inline">\(\Theta(\log
n)\)</span>。</p>
<h3 id="e-4">E</h3>
<p>容易发现选出一个位置后左右独立，所以设 <span
class="math inline">\(dp_{l,r}\)</span> 为 <span
class="math inline">\(l-1\)</span> 和 <span
class="math inline">\(r+1\)</span> 都已选中，<span
class="math inline">\([l,r]\)</span> 内都还未选中时，<span
class="math inline">\([l,r]\)</span> 内的期望贡献。</p>
<p>令设 <span class="math inline">\(S_{l,r}=\{p\in \mathbb N\mid l\le
p\le
r,a_{l-1}&lt;a_p&lt;a_{r+1}\}\)</span>，即区间内合法的凳子的集合。</p>
<p>则容易列出转移方程：</p>
<p><span
class="math display">\[dp_{l,r}=\begin{cases}0,&amp;S_{l,r}=\varnothing\\\displaystyle\frac1{|S_{l,r}|}\sum_{i\in
S_{l,r}}1+dp_{l,i-1}+dp_{i+1,r},&amp;S_{l,r}\ne\varnothing\end{cases}\]</span></p>
<p>对于每一项在值域上树状数组优化即可做到 <span
class="math inline">\(\Theta(n^2\log n)\)</span>。</p>
<h3 id="f-4">F</h3>
<p>考虑转换成对于每个 <span class="math inline">\(x\)</span> 计算 <span
class="math inline">\(\mathrm{niceness}\ge x\)</span> 的方案数。</p>
<p>考虑充要条件：上式不成立当且仅当距离 <span class="math inline">\(\ge
x\)</span> 的点对全部异色。</p>
<p>如果直径长度 <span class="math inline">\(&lt;x\)</span>
显然不可能成立。</p>
<p>如果有一个点到直径两端的距离都 <span class="math inline">\(\ge
x\)</span>，那么直径长度也 <span class="math inline">\(\ge
x\)</span>，显然必定成立。</p>
<p>否则一个点最多和一个直径端点距离 <span class="math inline">\(\ge
x\)</span>。考虑距离 <span class="math inline">\(\ge x\)</span>
的点对连一条边，那么不成立相当于这个图被二分图染色。</p>
<p>这个图的形状显然是直径两端各挂了一坨点，加上一坨孤立点。求孤立点数量也是好做的，直接
bfs 一下算一下到直径端点最短距离就行了。</p>
<h2 id="arc109">ARC109</h2>
<h3 id="d-5">D</h3>
<p>人类智慧 + 打表大法 题，无法理解，咕。</p>
<h3 id="e-5">E</h3>
<p>结论很神仙：</p>
<blockquote>
<p>如果两边颜色一样最后肯定全是那种，否则看两个最靠边的连通块哪个离初始点远，远的种颜色就只有那一段。</p>
</blockquote>
<p>证明略。</p>
<p>然后你考虑两边差的是哪一部分，注意到大多数都会被对称掉，那么剩下的就是距离相等的情况，这种情况必然是黑棋得到中间的。</p>
<p>然后再进行一堆 dirty 的推式子，你会得到一个对于钦定的起点的式子。</p>
<p>然后你发现这玩意每一位都是前一位加了一项，直接递推即可。<span
class="math inline">\(\Theta(n)\)</span>。</p>
<h3 id="f-5">F</h3>
<p>没做，咕。</p>
]]></content>
      <categories>
        <category>solutions</category>
        <category>AtCoder</category>
      </categories>
  </entry>
</search>
